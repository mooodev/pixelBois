<!DOCTYPE html>
<html lang="en">
<head>
    <title>PS1 Style Horror Game (Volumetric Snow)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-family: monospace;
        }
        #controls button {
            display: block;
            margin-bottom: 5px;
            cursor: pointer;
        }
        #controls p {
            margin: 10px 0 0 0;
            line-height: 1.4;
        }
        /* Style for the joystick container */
        #joystick-container {
            position: absolute; 
            bottom: 30px; 
            left: 30px; 
            width: 150px; 
            height: 150px; 
            display: none; /* Hidden by default, enabled by script */
            z-index: 110; 
        }
    </style>
</head>
<body>
    <!-- Game UI -->
    <div id="controls">
        <button id="snowBtn">Change Weather</button>
        <p>
            Current Weather: <span id="weatherStatus">Off</span>
        </p>
    </div>

    <!-- Mobile Joystick UI Container -->
    <div id="joystick-container"></div>
    
    <!-- NippleJS Library (must be loaded before the game module) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.151.3/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.151.3/examples/jsm/"
            }
        }
    </script>

    <!-- Main Game Logic -->
    <script type="module">
import * as THREE from 'three';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

// --- Corrected Simplex Noise Implementation ---
class SimplexNoise {
    constructor(r = "0123456789abcdef") {
        this.F2 = 0.5 * (Math.sqrt(3) - 1);
        this.G2 = (3 - Math.sqrt(3)) / 6;
        this.grad3 = new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]);
        
        const p = new Uint8Array(256);
        let e = 0;
        do {
            const t = r.charAt(e++);
            if (!t) break;
            p[e - 1] = t.charCodeAt(0);
        } while (e < 256);

        for (let i = 0; i < 255; i++) {
            const r = i + ~~(Math.random() * (256 - i));
            const t = p[i];
            p[i] = p[r];
            p[r] = t;
        }

        this.perm = new Uint8Array(512);
        this.permMod12 = new Uint8Array(512);

        for (let i = 0; i < 512; i++) {
            this.perm[i] = p[i & 255];
            this.permMod12[i] = this.perm[i] % 12;
        }
    }

    dot(g, x, y) {
        return g[g*3] * x + g[g*3+1] * y;
    }
    
    noise2D(xin, yin) {
        const perm = this.perm;
        const grad3 = this.grad3;
        let n0 = 0, n1 = 0, n2 = 0;
        
        const s = (xin + yin) * this.F2;
        const i = ~~(xin + s);
        const j = ~~(yin + s);
        const t = (i + j) * this.G2;
        
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = xin - X0;
        const y0 = yin - Y0;

        let i1, j1;
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } else {
            i1 = 0;
            j1 = 1;
        }

        const x1 = x0 - i1 + this.G2;
        const y1 = y0 - j1 + this.G2;
        const x2 = x0 - 1 + 2 * this.G2;
        const y2 = y0 - 1 + 2 * this.G2;

        const ii = i & 255;
        const jj = j & 255;
        
        const gi0 = this.permMod12[ii + perm[jj]];
        const gi1 = this.permMod12[ii + i1 + perm[jj + j1]];
        const gi2 = this.permMod12[ii + 1 + perm[jj + 1]];

        let t0 = 0.5 - x0 * x0 - y0 * y0;
        if (t0 >= 0) {
            t0 *= t0;
            n0 = t0 * t0 * (grad3[gi0 * 3] * x0 + grad3[gi0 * 3 + 1] * y0);
        }

        let t1 = 0.5 - x1 * x1 - y1 * y1;
        if (t1 >= 0) {
            t1 *= t1;
            n1 = t1 * t1 * (grad3[gi1 * 3] * x1 + grad3[gi1 * 3 + 1] * y1);
        }
        
        let t2 = 0.5 - x2 * x2 - y2 * y2;
        if (t2 >= 0) {
            t2 *= t2;
            n2 = t2 * t2 * (grad3[gi2 * 3] * x2 + grad3[gi2 * 3 + 1] * y2);
        }

        return 70 * (n0 + n1 + n2);
    }
}


// --- Professional Game Configuration ---
const GAME_CONFIG = {
    PLAYER: {
        MAX_SPEED: 4.0, RUN_MULTIPLIER: 2.0, ACCELERATION: 20.0, DECELERATION: 15.0, ROTATION_SPEED: Math.PI*1.5, SCALE: 0.02, VERTICAL_LERP_FACTOR: 0.05,
    },
    CAMERA: {
        FOV: 75, NEAR: 0.1, FAR: 1000, ZOOM_OFFSET: new THREE.Vector3(0, 4, -8), LOOK_AT_OFFSET: new THREE.Vector3(0, 2, 0), POSITION_LERP_FACTOR: 0.08, LOOK_AT_LERP_FACTOR: 0.1, HEAD_BOB_AMPLITUDE: 0.1, HEAD_BOB_FREQUENCY: 2.0,
    },
    SCENE: {
        RENDER_DISTANCE: 50, BACKGROUND_COLOR: 0x000000, FOG_COLOR: 0x050505, FOG_NEAR_FACTOR: 0.1,
    },
    LIGHTING: {
        AMBIENT_COLOR: 0x404050, AMBIENT_INTENSITY: 0.5, HEMISPHERE_SKY_COLOR: 0x303040, HEMISPHERE_GROUND_COLOR: 0x101020, HEMISPHERE_INTENSITY: 0.7, MOONLIGHT_COLOR: 0x404050, MOONLIGHT_INTENSITY: 1.2, PLAYER_LIGHT_COLOR: 0xffaa77, PLAYER_LIGHT_INTENSITY: 0.5, PLAYER_LIGHT_DISTANCE: 35,
    },
    SHADOWS: {
        MAP_SIZE: 1024,
    },
    TERRAIN: {
        WIDTH: 128, DEPTH: 128, SCALE: 2, CHECKER_DARK: '#3A2E1F', CHECKER_LIGHT: '#4A3E2F',
    },
    SNOW: {
        MAX_DEPTH: 2.0, DEFORMATION_RADIUS: 2.5, DEFORMATION_STRENGTH: 1.0, DRIFT_SCALE: 0.08, DRIFT_SPEED: 0.02,
        SINK_FACTOR: 0.4, 
    },
    GRASS: {
        COUNT: 500000, COLOR: '#BA8E23', SNOW_COLOR: '#FFFFFF',
    },
    STARS: {
        COUNT: 5000, RADIUS: 800, SIZE: 1.5,
    },
    ANIMATION_NAMES: {
        IDLE: 'idle', WALK: 'walking', WALK_BACK: 'walkingBackwards',
    },
    WEATHER: {
        MAX_SNOW_PARTICLES: 15000,
        LEVELS: [
            { name: "Off", active: false, particleCount: 0, particleSpeed: 0, particleWind: 0, particleSize: 0.1, accumulationRate: 0, driftAmount: 0.0, maxDepth: 0 },
            { name: "Light", active: true, particleCount: 4000, particleSpeed: 3, particleWind: 0.5, particleSize: 0.1, accumulationRate: 0.05, driftAmount: 0.1, maxDepth: 85 },
            { name: "Moderate", active: true, particleCount: 8000, particleSpeed: 7, particleWind: 2.0, particleSize: 0.12, accumulationRate: 0.15, driftAmount: 0.35, maxDepth: 170 },
            { name: "Blizzard", active: true, particleCount: 15000, particleSpeed: 18, particleWind: 8.0, particleSize: 0.15, accumulationRate: 0.4, driftAmount: 0.5, maxDepth: 255 }
        ]
    }
};

// --- Global Variables ---
let camera, scene, renderer, mixer;
const clock = new THREE.Clock();
const keys = {};
let joystickData = { x: 0, y: 0, active: false }; // joystick data is properly scoped here

const player = {
    model: null, animations: {}, currentAction: null, velocity: new THREE.Vector3(),
};

let grassMaterial;
let terrainData = {
    width: GAME_CONFIG.TERRAIN.WIDTH * GAME_CONFIG.TERRAIN.SCALE,
    depth: GAME_CONFIG.TERRAIN.DEPTH * GAME_CONFIG.TERRAIN.SCALE,
    heights: [],
};
let snowData = { texture: null, cpuData: null, preciseCpuData: null, noise: new SimplexNoise(), needsUpdate: false };
let terrainMesh;
const forwardVector = new THREE.Vector3();
const deformationPosition = new THREE.Vector3();
let snowActive = false;
let snowLevel = 0;
let snowParticles;
const idealCameraPosition = new THREE.Vector3();
const idealLookAt = new THREE.Vector3();
const currentCameraPosition = new THREE.Vector3();
const currentLookAt = new THREE.Vector3();
let headBobTime = 0;
let isFixedCamera = false;
let cameraIndex = -1;
const fixedCameraPositions = [
    new THREE.Vector3(15, 10, -25), new THREE.Vector3(30, 8, 30), new THREE.Vector3(-20, 12, 20), new THREE.Vector3(-40, 15, -10)
];

// --- INITIALIZATION ---
init();
animate();

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(GAME_CONFIG.SCENE.BACKGROUND_COLOR);
    scene.fog = new THREE.Fog(GAME_CONFIG.SCENE.FOG_COLOR, GAME_CONFIG.SCENE.RENDER_DISTANCE * GAME_CONFIG.SCENE.FOG_NEAR_FACTOR, GAME_CONFIG.SCENE.RENDER_DISTANCE);
    camera = new THREE.PerspectiveCamera(GAME_CONFIG.CAMERA.FOV, window.innerWidth / window.innerHeight, GAME_CONFIG.CAMERA.NEAR, GAME_CONFIG.CAMERA.FAR);
    currentCameraPosition.copy(GAME_CONFIG.CAMERA.ZOOM_OFFSET);
    currentLookAt.copy(GAME_CONFIG.CAMERA.LOOK_AT_OFFSET);
    camera.position.copy(currentCameraPosition);
    camera.lookAt(currentLookAt);
    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    
    createLighting();
    createTerrain();
    createGrass();
    createStars();
    createWeatherSystems();
    createCameraPoles();
    loadCharacter();
    setupEventListeners();
    setupMobileControls(); // *** CORRECTED: Setup joystick from within the module
}

function setupEventListeners() {
    document.addEventListener('keydown', (e) => (keys[e.key.toLowerCase()] = true));
    document.addEventListener('keyup', (e) => (keys[e.key.toLowerCase()] = false));
    window.addEventListener('resize', onWindowResize);
    document.getElementById('snowBtn').addEventListener('click', () => {
        snowLevel = (snowLevel + 1) % GAME_CONFIG.WEATHER.LEVELS.length;
        if (snowLevel === 0) resetSnow();
        document.getElementById('weatherStatus').textContent = GAME_CONFIG.WEATHER.LEVELS[snowLevel].name;
    });
}

// *** NEW FUNCTION to correctly set up joystick controls ***
function setupMobileControls() {
    const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    if (isMobile) {
        const joystickContainer = document.getElementById('joystick-container');
        joystickContainer.style.display = 'block';

        const joystick = nipplejs.create({
            zone: joystickContainer,
            mode: 'static',
            position: { left: '50%', top: '50%' },
            color: 'white',
            size: 150
        });

        joystick.on('move', function (evt, data) {
            joystickData.active = true;
            joystickData.x = data.vector.x;
            joystickData.y = data.vector.y;
        });

        joystick.on('end', function () {
            joystickData.active = false;
            joystickData.x = 0;
            joystickData.y = 0;
        });
    }
}

function createCameraPoles() {
    const poleGeo = new THREE.CylinderGeometry(0.2, 0.2, 20, 8);
    const cameraBoxGeo = new THREE.BoxGeometry(0.5, 0.4, 0.8);
    const material = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, metalness: 0.2 });
    fixedCameraPositions.forEach(pos => {
        const pole = new THREE.Mesh(poleGeo, material);
        const cameraBox = new THREE.Mesh(cameraBoxGeo, material);
        const groundY = getHeightAt(pos.x, pos.z) || 0;
        const poleHeight = pos.y - groundY;
        pole.geometry = new THREE.CylinderGeometry(0.2, 0.2, poleHeight, 8);
        pole.position.set(pos.x, groundY + poleHeight / 2, pos.z);
        cameraBox.position.copy(pos);
        cameraBox.lookAt(player.model ? player.model.position : new THREE.Vector3(0,0,0));
        scene.add(pole);
        scene.add(cameraBox);
    });
}

function createLighting() {
    scene.add(new THREE.AmbientLight(GAME_CONFIG.LIGHTING.AMBIENT_COLOR, GAME_CONFIG.LIGHTING.AMBIENT_INTENSITY));
    scene.add(new THREE.HemisphereLight(GAME_CONFIG.LIGHTING.HEMISPHERE_SKY_COLOR, GAME_CONFIG.LIGHTING.HEMISPHERE_GROUND_COLOR, GAME_CONFIG.LIGHTING.HEMISPHERE_INTENSITY));
    const moonLight = new THREE.DirectionalLight(GAME_CONFIG.LIGHTING.MOONLIGHT_COLOR, GAME_CONFIG.LIGHTING.MOONLIGHT_INTENSITY);
    moonLight.position.set(30, 50, -30);
    moonLight.castShadow = true;
    moonLight.shadow.mapSize.width = GAME_CONFIG.SHADOWS.MAP_SIZE;
    moonLight.shadow.mapSize.height = GAME_CONFIG.SHADOWS.MAP_SIZE;
    scene.add(moonLight);
}

function createTerrain() {
    const { WIDTH, DEPTH } = GAME_CONFIG.TERRAIN;
    terrainData.heights = Array(WIDTH).fill(0).map(() => Array(DEPTH));
    for (let x = 0; x < WIDTH; x++) {
        for (let y = 0; y < DEPTH; y++) {
            terrainData.heights[x][y] = (Math.sin(x * 0.1) + Math.cos(y * 0.1)) * 2;
        }
    }
    const geometry = new THREE.PlaneGeometry(terrainData.width, terrainData.depth, WIDTH - 1, DEPTH - 1);
    geometry.rotateX(-Math.PI / 2);
    const verts = geometry.attributes.position.array;
    for (let i = 0, j = 0; i < verts.length; i += 3, j++) {
        verts[i + 1] = terrainData.heights[j % WIDTH][Math.floor(j / WIDTH)];
    }
    geometry.computeVertexNormals();
    const dataSize = WIDTH * DEPTH;
    snowData.cpuData = new Uint8Array(4 * dataSize);
    snowData.preciseCpuData = new Float32Array(dataSize);
    for (let i = 0; i < dataSize; i++) {
        snowData.preciseCpuData[i] = 0;
        snowData.cpuData[i * 4] = 0;
        snowData.cpuData[i * 4 + 3] = 255;
    }
    snowData.texture = new THREE.DataTexture(snowData.cpuData, WIDTH, DEPTH, THREE.RGBAFormat);
    snowData.texture.needsUpdate = true;
    const textureCanvas = document.createElement('canvas');
    textureCanvas.width = 2; textureCanvas.height = 2;
    const context = textureCanvas.getContext('2d');
    context.fillStyle = GAME_CONFIG.TERRAIN.CHECKER_DARK; context.fillRect(0, 0, 2, 2);
    context.fillStyle = GAME_CONFIG.TERRAIN.CHECKER_LIGHT; context.fillRect(0, 0, 1, 1); context.fillRect(1, 1, 1, 1);
    const checkerTexture = new THREE.CanvasTexture(textureCanvas);
    checkerTexture.wrapS = THREE.RepeatWrapping; checkerTexture.wrapT = THREE.RepeatWrapping;
    checkerTexture.repeat.set(WIDTH / 2, DEPTH / 2);
    checkerTexture.magFilter = THREE.NearestFilter;
    const terrainMaterial = new THREE.MeshStandardMaterial({ map: checkerTexture, flatShading: true });
    terrainMaterial.onBeforeCompile = (shader) => {
        shader.uniforms.uSnowDepthMap = { value: snowData.texture };
        shader.uniforms.uMaxSnowDepth = { value: GAME_CONFIG.SNOW.MAX_DEPTH };
        shader.uniforms.uTime = { value: 0 };
        shader.uniforms.uSnowSpecularColor = { value: new THREE.Color(0x9999FF) };
        shader.vertexShader = `
            uniform sampler2D uSnowDepthMap; uniform float uMaxSnowDepth; varying float vSnowDepth; varying vec3 vWorldNormal; varying vec3 vWorldPosition;
        ` + shader.vertexShader;
        shader.vertexShader = shader.vertexShader.replace('#include <worldpos_vertex>',`#include <worldpos_vertex>\nvWorldPosition = worldPosition.xyz;`);
        shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>',`
            #include <begin_vertex>
            vSnowDepth = texture2D(uSnowDepthMap, uv).r;
            transformed += normal * vSnowDepth * uMaxSnowDepth;
            vWorldNormal = normalize( normalMatrix * normal );`);
        shader.fragmentShader = `
            varying float vSnowDepth; varying vec3 vWorldNormal; varying vec3 vWorldPosition; uniform float uTime; uniform vec3 uSnowSpecularColor;
        ` + shader.fragmentShader;
        shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>',`
            #include <dithering_fragment>
            vec3 snowColor = vec3(0.95, 0.95, 1.0);
            float ambientOcclusion = 1.0 - vSnowDepth * 0.3; snowColor *= ambientOcclusion;
            vec3 viewDir = normalize(vViewPosition); vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0)); vec3 halfDir = normalize(lightDir + viewDir);
            float spec = pow(max(dot(vWorldNormal, halfDir), 0.0), 32.0);
            float sparkle = smoothstep(0.98, 1.0, sin((vWorldPosition.x + vWorldPosition.z) * 500.0 + uTime * 5.0));
            vec3 specular = uSnowSpecularColor * spec * sparkle;
            float snowMix = smoothstep(0.05, 0.15, vSnowDepth);
            gl_FragColor.rgb = mix(gl_FragColor.rgb, snowColor + specular, snowMix);`);
        terrainMaterial.userData.shader = shader;
    };
    terrainMesh = new THREE.Mesh(geometry, terrainMaterial);
    terrainMesh.receiveShadow = true;
    scene.add(terrainMesh);
}

function resetSnow() {
    const { WIDTH, DEPTH } = GAME_CONFIG.TERRAIN;
    const dataSize = WIDTH * DEPTH;
    for (let i = 0; i < dataSize; i++) {
        snowData.preciseCpuData[i] = 0;
        snowData.cpuData[i * 4] = 0;
    }
    snowData.needsUpdate = true;
}

function createGrass() {
    const grassCanvas = document.createElement('canvas');
    grassCanvas.width = 8; grassCanvas.height = 16;
    const grassCtx = grassCanvas.getContext('2d');
    grassCtx.fillStyle = GAME_CONFIG.GRASS.COLOR;
    grassCtx.fillRect(3, 0, 2, 16);
    const grassTexture = new THREE.CanvasTexture(grassCanvas);
    grassTexture.magFilter = THREE.NearestFilter;
    grassMaterial = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 }, tex: { value: grassTexture }, fogColor: { value: scene.fog.color }, fogNear: { value: scene.fog.near }, fogFar: { value: scene.fog.far }, playerPosition: { value: new THREE.Vector3() }, renderDistance: { value: GAME_CONFIG.SCENE.RENDER_DISTANCE }, playerVelocity: { value: new THREE.Vector3() }, snowActive: { value: 0.0 }, grassColor: { value: new THREE.Color(GAME_CONFIG.GRASS.COLOR) }, snowColor: { value: new THREE.Color(GAME_CONFIG.GRASS.SNOW_COLOR) } },
        vertexShader: `
            uniform float time; uniform vec3 playerPosition; uniform vec3 playerVelocity; uniform float renderDistance; uniform float snowActive; varying vec2 vUv; varying float vFogDepth;
            void main() {
                vec4 instanceWorldPos = instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);
                float distToPlayer = distance(instanceWorldPos.xyz, playerPosition);
                if (distToPlayer > renderDistance) { gl_Position = vec4(0.0, 0.0, 0.0, 0.0); return; }
                vUv = uv; vec3 pos = position; float interactionRadius = 4.0;
                if (distToPlayer < interactionRadius) {
                    float effectStrength = smoothstep(0.0, 1.0, 1.0 - (distToPlayer / interactionRadius));
                    vec3 dirFromPlayer = normalize(instanceWorldPos.xyz - playerPosition); dirFromPlayer.y = 0.0;
                    vec3 combinedDir = length(playerVelocity) > 0.01 ? normalize(dirFromPlayer + normalize(playerVelocity)) : dirFromPlayer;
                    if (pos.y > 0.0) { pos.xz += combinedDir.xz * effectStrength * 0.6; pos.x += sin(time * 20.0 + instanceWorldPos.x) * 0.1 * effectStrength; }
                }
                if (pos.y > 0.0 && snowActive > 0.1) {
                    float swayStrength = snowActive * 0.2; pos.x += sin(time * 1.5 + instanceWorldPos.x * 0.5) * swayStrength; pos.z += cos(time * 1.0 + instanceWorldPos.z * 0.5) * swayStrength * 0.5;
                }
                vec4 modelViewPosition = modelViewMatrix * instanceMatrix * vec4(pos, 1.0); vFogDepth = -modelViewPosition.z; gl_Position = projectionMatrix * modelViewPosition;
            }`,
        fragmentShader: `
            uniform sampler2D tex; uniform vec3 fogColor; uniform float fogNear; uniform float fogFar; uniform float snowActive; uniform vec3 grassColor; uniform vec3 snowColor; varying vec2 vUv; varying float vFogDepth;
            void main() {
                vec4 texColor = texture2D(tex, vUv); if (texColor.a < 0.1) discard;
                vec3 finalColor = mix(grassColor, snowColor, snowActive); gl_FragColor = vec4(finalColor, texColor.a);
                float fogFactor = smoothstep(fogNear, fogFar, vFogDepth); gl_FragColor = mix(gl_FragColor, vec4(fogColor, gl_FragColor.a), fogFactor);
            }`,
        transparent: true, side: THREE.DoubleSide, fog: true
    });
    const grassGeometry = new THREE.PlaneGeometry(0.5, 1.5, 1, 3);
    grassGeometry.translate(0, 0.75, 0);
    const instancedGrass = new THREE.InstancedMesh(grassGeometry, grassMaterial, GAME_CONFIG.GRASS.COUNT);
    instancedGrass.receiveShadow = true;
    scene.add(instancedGrass);
    const dummy = new THREE.Object3D();
    for (let i = 0; i < GAME_CONFIG.GRASS.COUNT; i++) {
        const x = Math.random() * terrainData.width - terrainData.width / 2;
        const z = Math.random() * terrainData.depth - terrainData.depth / 2;
        const y = getHeightAt(x, z);
        if (y !== undefined) {
             dummy.position.set(x, y, z); dummy.rotation.y = Math.random() * Math.PI; dummy.updateMatrix(); instancedGrass.setMatrixAt(i, dummy.matrix);
        }
    }
    instancedGrass.instanceMatrix.needsUpdate = true;
}

function createStars() {
    const starGeometry = new THREE.BufferGeometry(); const starVertices = [];
    for (let i = 0; i < GAME_CONFIG.STARS.COUNT; i++) {
        starVertices.push((Math.random() - 0.5) * 2 * GAME_CONFIG.STARS.RADIUS, Math.random() * GAME_CONFIG.STARS.RADIUS + 50, (Math.random() - 0.5) * 2 * GAME_CONFIG.STARS.RADIUS);
    }
    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
    scene.add(new THREE.Points(starGeometry, new THREE.PointsMaterial({ color: 0xffffff, size: GAME_CONFIG.STARS.SIZE, transparent: true, fog: false })));
}

function createWeatherSystems() {
    const snowGeo = new THREE.BufferGeometry(); const snowVertices = [];
    for(let i=0; i < GAME_CONFIG.WEATHER.MAX_SNOW_PARTICLES; i++) {
        snowVertices.push(Math.random() * terrainData.width - terrainData.width / 2, Math.random() * 50, Math.random() * terrainData.depth - terrainData.depth / 2);
    }
    snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowVertices, 3));
    snowParticles = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, fog: false }));
    snowParticles.visible = false;
    scene.add(snowParticles);
}

function loadCharacter() {
    const loader = new FBXLoader();
    const { IDLE, WALK, WALK_BACK } = GAME_CONFIG.ANIMATION_NAMES;
    loader.load('https://raw.githubusercontent.com/mooodev/pixelBois/main/webGame/images/Idle.fbx', (fbx) => {
        player.model = fbx;
        player.model.scale.setScalar(GAME_CONFIG.PLAYER.SCALE);
        player.model.position.y = getHeightAt(0, 0) || 0;
        scene.add(player.model);
        const { PLAYER_LIGHT_COLOR, PLAYER_LIGHT_INTENSITY, PLAYER_LIGHT_DISTANCE } = GAME_CONFIG.LIGHTING;
        const pointLight = new THREE.PointLight(PLAYER_LIGHT_COLOR, PLAYER_LIGHT_INTENSITY, PLAYER_LIGHT_DISTANCE);
        pointLight.position.set(0, 250, 0); pointLight.castShadow = true; player.model.add(pointLight);
        player.model.traverse((child) => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } });
        mixer = new THREE.AnimationMixer(player.model);
        player.animations[IDLE] = mixer.clipAction(fbx.animations[0]);
        player.currentAction = player.animations[IDLE];
        player.currentAction.play();
        loadAnimation(loader, 'https://raw.githubusercontent.com/mooodev/pixelBois/main/webGame/images/Walking.fbx', WALK);
        loadAnimation(loader, 'https://raw.githubusercontent.com/mooodev/pixelBois/main/webGame/images/Backwards.fbx', WALK_BACK);
    }, undefined, (error) => console.error(error));
}

function loadAnimation(loader, url, name) {
    loader.load(url, (fbx) => {
        if (fbx.animations && fbx.animations.length) {
            player.animations[name] = mixer.clipAction(fbx.animations[0]);
        }
    }, undefined, (error) => console.error(error));
}

function getHeightAt(x, z) {
    const { WIDTH, DEPTH } = GAME_CONFIG.TERRAIN;
    const x_i = Math.floor((x + terrainData.width / 2) / GAME_CONFIG.TERRAIN.SCALE);
    const z_i = Math.floor((z + terrainData.depth / 2) / GAME_CONFIG.TERRAIN.SCALE);
    if (x_i >= 0 && x_i < WIDTH && z_i >= 0 && z_i < DEPTH) {
        return terrainData.heights[x_i][z_i];
    }
    return undefined;
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function switchAnimation(newActionName, duration = 0.2) {
    const newAction = player.animations[newActionName];
    if (!newAction || newAction === player.currentAction) return;
    const previousAction = player.currentAction;
    player.currentAction = newAction;
    if (previousAction) previousAction.fadeOut(duration);
    newAction.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(duration).play();
}

// *** FINALIZED updatePlayer FUNCTION to handle both keyboard and joystick ***
function updatePlayer(delta) {
    if (!player.model || !mixer) return;

    const { ACCELERATION, DECELERATION, MAX_SPEED, ROTATION_SPEED, VERTICAL_LERP_FACTOR, RUN_MULTIPLIER } = GAME_CONFIG.PLAYER;
    const { SINK_FACTOR } = GAME_CONFIG.SNOW;
    const { IDLE, WALK, WALK_BACK } = GAME_CONFIG.ANIMATION_NAMES;
    
    const isRunning = keys['shift']; 
    const currentMaxSpeed = isRunning ? MAX_SPEED * RUN_MULTIPLIER : MAX_SPEED;

    let rotationDelta = 0;

    // --- Joystick Control Logic ---
    if (joystickData.active) {
        // Directly map joystick vector to player velocity and rotation
        player.velocity.z = joystickData.y * currentMaxSpeed; 
        rotationDelta = -joystickData.x * ROTATION_SPEED * delta;
    } else {
        // --- Keyboard Control Logic (Fallback) ---
        if (keys['w'] || keys['arrowup']) player.velocity.z += ACCELERATION * delta;
        else if (keys['s'] || keys['arrowdown']) player.velocity.z -= ACCELERATION * delta;
        else { // Deceleration when no input is given
            if (player.velocity.z > 0) player.velocity.z = Math.max(0, player.velocity.z - DECELERATION * delta);
            else if (player.velocity.z < 0) player.velocity.z = Math.min(0, player.velocity.z + DECELERATION * delta);
        }
        player.velocity.z = THREE.MathUtils.clamp(player.velocity.z, -currentMaxSpeed, currentMaxSpeed);

        if (keys['a'] || keys['arrowleft']) rotationDelta += ROTATION_SPEED * delta;
        if (keys['d'] || keys['arrowright']) rotationDelta -= ROTATION_SPEED * delta;
    }

    // --- Apply Movement and Rotation ---
    player.model.rotateY(rotationDelta);
    player.model.translateZ(player.velocity.z * delta);

    // --- Vertical Positioning (Ground and Snow) ---
    const currentPos = player.model.position;
    const terrainY = getHeightAt(currentPos.x, currentPos.z);
    const texIndex = ((Math.floor(((currentPos.z + terrainData.depth / 2) / terrainData.depth) * GAME_CONFIG.TERRAIN.DEPTH) * GAME_CONFIG.TERRAIN.WIDTH) + Math.floor(((currentPos.x + terrainData.width / 2) / terrainData.width) * GAME_CONFIG.TERRAIN.WIDTH)) * 4;
    const snowDepthHere = snowData.cpuData ? (snowData.cpuData[texIndex] / 255.0) * GAME_CONFIG.SNOW.MAX_DEPTH : 0;
    const finalY = (terrainY !== undefined ? terrainY : currentPos.y) + (snowDepthHere * SINK_FACTOR);
    player.model.position.y = THREE.MathUtils.lerp(currentPos.y, finalY, 1.0 - Math.pow(1.0 - VERTICAL_LERP_FACTOR, delta * 60));

    // --- Update Animations ---
    let newState = (Math.abs(player.velocity.z) > 0.1) ? (player.velocity.z > 0 ? WALK : WALK_BACK) : IDLE;
    switchAnimation(newState);

    if (player.currentAction) {
        const speedRatio = Math.abs(player.velocity.z) / currentMaxSpeed;
        const timeScale = isRunning ? (speedRatio * 1.5 + 0.5) : (speedRatio * 0.5 + 0.5);
        player.currentAction.setEffectiveTimeScale(Math.max(0.1, timeScale)); 
    }
    mixer.update(delta);
}

function updateCamera(delta) {
    if (!player.model) return;
    const wasFixed = isFixedCamera;
    let closestPoleIndex = -1;
    let minDistance = Infinity;
    const triggerDistance = GAME_CONFIG.SCENE.RENDER_DISTANCE / 2;
    fixedCameraPositions.forEach((polePosition, index) => {
        const distance = player.model.position.distanceTo(polePosition);
        if (distance < minDistance) { minDistance = distance; closestPoleIndex = index; }
    });
    isFixedCamera = (minDistance < triggerDistance);
    cameraIndex = isFixedCamera ? closestPoleIndex : -1;

    if (isFixedCamera) {
        const targetPosition = fixedCameraPositions[cameraIndex];
        camera.position.lerp(targetPosition, delta * 4.0);
        camera.lookAt(player.model.position.clone().add(GAME_CONFIG.CAMERA.LOOK_AT_OFFSET));
        headBobTime = 0;
    } else {
        const { ZOOM_OFFSET, LOOK_AT_OFFSET, POSITION_LERP_FACTOR, LOOK_AT_LERP_FACTOR, HEAD_BOB_AMPLITUDE, HEAD_BOB_FREQUENCY } = GAME_CONFIG.CAMERA;
        idealCameraPosition.copy(player.model.position).add(ZOOM_OFFSET.clone().applyQuaternion(player.model.quaternion));
        idealLookAt.copy(player.model.position).add(LOOK_AT_OFFSET);
        if (wasFixed && !isFixedCamera) {
            currentCameraPosition.copy(idealCameraPosition);
            currentLookAt.copy(idealLookAt);
        }
        currentCameraPosition.lerp(idealCameraPosition, 1.0 - Math.pow(1.0 - POSITION_LERP_FACTOR, delta * 60));
        currentLookAt.lerp(idealLookAt, 1.0 - Math.pow(1.0 - LOOK_AT_LERP_FACTOR, delta * 60));
        camera.position.copy(currentCameraPosition);
        const isMoving = player.currentAction === player.animations[GAME_CONFIG.ANIMATION_NAMES.WALK] || player.currentAction === player.animations[GAME_CONFIG.ANIMATION_NAMES.WALK_BACK];
        if (isMoving) {
            const speedRatio = Math.abs(player.velocity.z) / currentMaxSpeed;
            headBobTime += delta * HEAD_BOB_FREQUENCY * speedRatio;
            camera.position.y += Math.sin(headBobTime) * HEAD_BOB_AMPLITUDE;
        } else {
            headBobTime = 0;
        }
        camera.lookAt(currentLookAt);
    }
}

function updateSnowDeformation() {
    if (!player.model || !snowData.cpuData || player.velocity.lengthSq() < 0.01) return;
    const { WIDTH, DEPTH } = GAME_CONFIG.TERRAIN;
    const { DEFORMATION_RADIUS, DEFORMATION_STRENGTH } = GAME_CONFIG.SNOW;
    const terrainHalfWidth = terrainData.width / 2;
    const terrainHalfDepth = terrainData.depth / 2;
    player.model.getWorldDirection(forwardVector);
    player.model.getWorldPosition(deformationPosition);
    deformationPosition.addScaledVector(forwardVector, 0.5);
    const texX = Math.floor(((deformationPosition.x + terrainHalfWidth) / terrainData.width) * WIDTH);
    const texY = Math.floor(((-1 * deformationPosition.z + terrainHalfDepth) / terrainData.depth) * DEPTH);
    const radiusInTexels = Math.floor((DEFORMATION_RADIUS / terrainData.width) * WIDTH);
    for (let i = -radiusInTexels; i <= radiusInTexels; i++) {
        for (let j = -radiusInTexels; j <= radiusInTexels; j++) {
            const currentTexX = texX + j;
            const currentTexY = texY + i;
            if (currentTexX >= 0 && currentTexX < WIDTH && currentTexY >= 0 && currentTexY < DEPTH) {
                const dist = Math.sqrt(i * i + j * j);
                if (dist < radiusInTexels) {
                    const falloff = 1.0 - (dist / radiusInTexels);
                    const deformationAmount = falloff * DEFORMATION_STRENGTH;
                    const index = (currentTexY * WIDTH + currentTexX);
                    let currentDepth = snowData.preciseCpuData[index];
                    const newDepth = Math.max(0, currentDepth - deformationAmount * 255 * 0.4);
                    if (newDepth < currentDepth) {
                        snowData.preciseCpuData[index] = newDepth;
                        snowData.cpuData[index * 4] = newDepth;
                        snowData.needsUpdate = true;
                    }
                }
            }
        }
    }
}

function updateWeather(delta) {
    const settings = GAME_CONFIG.WEATHER.LEVELS[snowLevel];
    snowActive = settings.active;
    snowParticles.visible = snowActive;
    if (!snowActive) return;
    snowParticles.material.size = settings.particleSize;
    snowParticles.geometry.setDrawRange(0, settings.particleCount);
    const positions = snowParticles.geometry.attributes.position.array;
    for (let i = 0; i < settings.particleCount * 3; i += 3) {
        positions[i+1] -= settings.particleSpeed * delta;
        positions[i] += (Math.random() - 0.5) * settings.particleWind * delta;
        if (positions[i+1] < 0) positions[i+1] = 50 + Math.random() * 20;
        if (positions[i] > terrainData.width / 2) positions[i] = -terrainData.width / 2;
        else if (positions[i] < -terrainData.width / 2) positions[i] = terrainData.width / 2;
    }
    snowParticles.geometry.attributes.position.needsUpdate = true;
    const { DRIFT_SCALE, DRIFT_SPEED } = GAME_CONFIG.SNOW;
    const { WIDTH, DEPTH } = GAME_CONFIG.TERRAIN;
    const time = clock.getElapsedTime();
    for (let y = 0; y < DEPTH; y++) {
        for (let x = 0; x < WIDTH; x++) {
            const driftFactor = (snowData.noise.noise2D(x * DRIFT_SCALE + time * DRIFT_SPEED, y * DRIFT_SCALE + time * DRIFT_SPEED) + 1) / 2;
            const accumulation = settings.accumulationRate * (1.0 - settings.driftAmount + (driftFactor * settings.driftAmount * 2.0));
            const index = (y * WIDTH + x);
            let currentDepth = snowData.preciseCpuData[index];
            if (currentDepth < settings.maxDepth) {
                currentDepth += accumulation * delta * 255;
                snowData.preciseCpuData[index] = Math.min(settings.maxDepth, currentDepth);
                snowData.cpuData[index * 4] = snowData.preciseCpuData[index];
                snowData.needsUpdate = true;
            }
        }
    }
}

function animate() {
    requestAnimationFrame(animate);
    const delta = Math.min(clock.getDelta(), 0.05);
    const elapsedTime = clock.getElapsedTime();
    if (terrainMesh && terrainMesh.material.userData.shader) {
        terrainMesh.material.userData.shader.uniforms.uTime.value = elapsedTime;
    }
    updateSnowDeformation();
    updatePlayer(delta);
    updateCamera(delta);
    updateWeather(delta);
    if (snowData.needsUpdate) {
        snowData.texture.needsUpdate = true;
        snowData.needsUpdate = false;
    }
    if (grassMaterial) {
        grassMaterial.uniforms.time.value = elapsedTime;
        grassMaterial.uniforms.snowActive.value = THREE.MathUtils.lerp(grassMaterial.uniforms.snowActive.value, snowActive ? 1.0 : 0.0, delta * 2.0);
        if(player.model) {
            player.model.getWorldPosition(grassMaterial.uniforms.playerPosition.value);
            grassMaterial.uniforms.playerVelocity.value.copy(player.velocity);
        }
    }
    renderer.render(scene, camera);
}
</script>

</body>
</html>
