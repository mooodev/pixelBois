<!DOCTYPE html>
<html lang="en">
<head>
    <title>PS1 Style Third-Person Game</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.151.3/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.151.3/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // --- Shader Definition ---
        // By defining the shader object here, we remove the need
        // for an external file that doesn't exist on the CDN.
        const PixelShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'resolution': { value: new THREE.Vector2() },
                'pixelSize': { value: 1 },
            },
            vertexShader: /* glsl */`
                varying highp vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`,
            fragmentShader: /* glsl */`
                uniform sampler2D tDiffuse;
                uniform float pixelSize;
                uniform vec2 resolution;
                varying highp vec2 vUv;
                void main(){
                    vec2 dxy = pixelSize / resolution;
                    vec2 coord = dxy * floor( vUv / dxy );
                    gl_FragColor = texture2D(tDiffuse, coord);
                }`
        };

        let camera, scene, renderer, composer;
        let mixer;
        const clock = new THREE.Clock();
        let player = { model: null, speed: 5, rotationSpeed: Math.PI / 2, state: 'idle' };
        const keys = {};

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0a0a0);
            scene.fog = new THREE.Fog(0xa0a0a0, 20, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false }); // No antialiasing for PS1 look
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // PS1 Style Post-Processing
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const pixelPass = new ShaderPass(PixelShader);
            pixelPass.uniforms["resolution"].value = new THREE.Vector2(window.innerWidth, window.innerHeight);
            pixelPass.uniforms["resolution"].value.multiplyScalar(window.devicePixelRatio);
            pixelPass.uniforms["pixelSize"].value = 8; // Adjust this for a more or less pixelated look
            composer.addPass(pixelPass);

            // Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff);
            dirLight.position.set(0, 20, 10);
            scene.add(dirLight);

            // Ground
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshPhongMaterial({ color: 0x999999, depthWrite: false }));
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            // Load Character
            const loader = new FBXLoader();
            loader.load('https://github.com/mooodev/pixelBois/raw/refs/heads/main/webGame/images/Running.fbx', function (object) {
                mixer = new THREE.AnimationMixer(object);
                const action = mixer.clipAction(object.animations[0]);
                action.play();
                player.model = object;
                player.model.scale.set(0.02, 0.02, 0.02);
                scene.add(player.model);
            });

            // Controls
            document.addEventListener('keydown', (e) => (keys[e.key] = true));
            document.addEventListener('keyup', (e) => (keys[e.key] = false));

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            const pixelPass = composer.passes[1];
            pixelPass.uniforms["resolution"].value.set(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio);
        }

        function updatePlayer(delta) {
            if (!player.model) return;

            let isMoving = false;

            if (keys['w'] || keys['W'] || keys['ArrowUp']) {
                player.model.translateZ(player.speed * delta);
                isMoving = true;
            }
            if (keys['s'] || keys['S'] || keys['ArrowDown']) {
                player.model.translateZ(-player.speed * delta);
                isMoving = true;
            }
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) {
                player.model.rotateY(player.rotationSpeed * delta);
            }
            if (keys['d'] || keys['D'] || keys['ArrowRight']) {
                player.model.rotateY(-player.rotationSpeed * delta);
            }

            if (isMoving && player.state !== 'running') {
                mixer.clipAction(player.model.animations[0]).play();
                player.state = 'running';
            } else if (!isMoving && player.state === 'running') {
                 // You could stop the animation here, but for this FBX, letting it loop looks fine.
                 player.state = 'idle';
            }

            if (mixer) {
                mixer.update(delta);
            }
        }

        function updateCamera() {
            if (!player.model) return;

            const offset = new THREE.Vector3(0, 4, -8);
            offset.applyQuaternion(player.model.quaternion);

            const cameraPosition = player.model.position.clone().add(offset);
            camera.position.lerp(cameraPosition, 0.1);
            camera.lookAt(player.model.position.clone().add(new THREE.Vector3(0, 2, 0)));
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            updatePlayer(delta);
            updateCamera();
            composer.render();
        }
    </script>
</body>
</html>
